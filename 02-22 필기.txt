■ 이원 교차표 p108

문제177.  직업(가로), 부서번호(세로), 직업별 부서번호별 인원수를 출력하시오 !   (tapply 함수 사용)

	     ANALYST CLERK MANAGER PRESIDENT SALESMAN
	10       0     1       1         1        0
	20       2     2       1         0        0
	30       0     1       1         0        4

	tapply( emp$empno, list(emp$deptno, emp$job), length, default=0)

		* 이원 교차표란 ?  

			  두 명목 변수간의 관계를 관찰하기 위해 이원 교차표를 사용한다







문제178. 위의 결과를 이원 교차표를 출력하는 CrossTable 함수를 이용해서 위의 결과를 출력하시오 ! 

	install.packages("gmodels")
	library(gmodels)
	CrossTable(x=emp$deptno, y=emp$job) 

	   Cell Contents
	|-------------------------|
	|                       N |
	| Chi-square contribution |
	|           N / Row Total |
	|           N / Col Total |
	|         N / Table Total |
	|-------------------------|
	
	 
	Total Observations in Table:  15 
	
	 
	             | emp$job 
	  emp$deptno |   ANALYST |     CLERK |   MANAGER | PRESIDENT |  SALESMAN | Row Total | 
	-------------|-----------|-----------|-----------|-----------|-----------|-----------|
	          10 |         0 |         1 |         1 |         1 |         0 |         3 | 
	             |     0.400 |     0.000 |     0.267 |     3.200 |     0.800 |           | 
	             |     0.000 |     0.333 |     0.333 |     0.333 |     0.000 |     0.200 | 
	             |     0.000 |     0.200 |     0.333 |     1.000 |     0.000 |           | 
	             |     0.000 |     0.067 |     0.067 |     0.067 |     0.000 |           | 
	-------------|-----------|-----------|-----------|-----------|-----------|-----------|
	          20 |         2 |         2 |         1 |         0 |         0 |         5 | 
	             |     2.667 |     0.067 |     0.000 |     0.333 |     1.333 |           | 
	             |     0.400 |     0.400 |     0.200 |     0.000 |     0.000 |     0.333 | 
	             |     1.000 |     0.400 |     0.333 |     0.000 |     0.000 |           | 
	             |     0.133 |     0.133 |     0.067 |     0.000 |     0.000 |           | 
	-------------|-----------|-----------|-----------|-----------|-----------|-----------|
	          30 |         0 |         1 |         1 |         0 |         4 |         6 | 
	             |     0.800 |     0.500 |     0.033 |     0.400 |     3.600 |           | 
	             |     0.000 |     0.167 |     0.167 |     0.000 |     0.667 |     0.400 | 
	             |     0.000 |     0.200 |     0.333 |     0.000 |     1.000 |           | 
	             |     0.000 |     0.067 |     0.067 |     0.000 |     0.267 |           | 
	-------------|-----------|-----------|-----------|-----------|-----------|-----------|
	          70 |         0 |         1 |         0 |         0 |         0 |         1 | 
	             |     0.133 |     1.333 |     0.200 |     0.067 |     0.267 |           | 
	             |     0.000 |     1.000 |     0.000 |     0.000 |     0.000 |     0.067 | 
	             |     0.000 |     0.200 |     0.000 |     0.000 |     0.000 |           | 
	             |     0.000 |     0.067 |     0.000 |     0.000 |     0.000 |           | 
	-------------|-----------|-----------|-----------|-----------|-----------|-----------|
	Column Total |         2 |         5 |         3 |         1 |         4 |        15 | 
	             |     0.133 |     0.333 |     0.200 |     0.067 |     0.267 |           | 
	-------------|-----------|-----------|-----------|-----------|-----------|-----------|





문제179. 직업별로 월급의 차이가 존재하는지 이원교차표로 확인하시오
         월급 2500 을 기준으로 직업별로 각각 월급이 2500 이상인 사원과 2500 보다 적은 사원들의 
	 어떻게 분포가 되어있는지 확인하시오 !

	library(data.table)
	data.table(emp$sal, emp$sal >= 2500) 
	
	      V1    V2
	 1: 5000  TRUE
	 2: 2850  TRUE
	 3: 2450 FALSE
	 4: 2975  TRUE
	 5: 1250 FALSE
	 6: 1600 FALSE
	 7: 1500 FALSE
	 8:  950 FALSE
	 9: 1250 FALSE
	10: 3000  TRUE
	11:  800 FALSE
	12: 3000  TRUE
	13: 1100 FALSE
	14: 1300 FALSE
	
	CrossTable( emp$job, emp$sal>= 2500)  
	
	     emp$job |     FALSE |      TRUE | Row Total | 
	-------------|-----------|-----------|-----------|
	     ANALYST |         0 |         2 |         2 | 
	             |     1.286 |     2.314 |           | 
	             |     0.000 |     1.000 |     0.143 | 
	             |     0.000 |     0.400 |           | 
	             |     0.000 |     0.143 |           | 
	-------------|-----------|-----------|-----------|
	       CLERK |         4 |         0 |         4 | 
	             |     0.794 |     1.429 |           | 
	             |     1.000 |     0.000 |     0.286 | 
	             |     0.444 |     0.000 |           | 
	             |     0.286 |     0.000 |           | 
	-------------|-----------|-----------|-----------|
	     MANAGER |         1 |         2 |         3 | 
	             |     0.447 |     0.805 |           | 
	             |     0.333 |     0.667 |     0.214 | 
	             |     0.111 |     0.400 |           | 
	             |     0.071 |     0.143 |           | 
	-------------|-----------|-----------|-----------|
	   PRESIDENT |         0 |         1 |         1 | 
	             |     0.643 |     1.157 |           | 
	             |     0.000 |     1.000 |     0.071 | 
	             |     0.000 |     0.200 |           | 
	             |     0.000 |     0.071 |           | 
	-------------|-----------|-----------|-----------|
	    SALESMAN |         4 |         0 |         4 | 
	             |     0.794 |     1.429 |           | 
	             |     1.000 |     0.000 |     0.286 | 
	             |     0.444 |     0.000 |           | 
	             |     0.286 |     0.000 |           | 
	-------------|-----------|-----------|-----------|
	Column Total |         9 |         5 |        14 | 
	             |     0.643 |     0.357 |           | 
	-------------|-----------|-----------|-----------|













■ 머신러닝에서 이원교차표를 어떻게 활용하는가 ?

	학습시킨 모델의 정확도를 확인하고 분석하기 위해서 사용한다.

	 P -> 암     ,  T -> 맞춘것이고
	 N -> 정상   ,  F -> 틀린것이다.











■ R 에서의 함수 생성 방법

     * 함수생성하는 문법

	 함수명 <-  function(인수 또는 입력값) {
	                 
	                    계산 처리1
	                    계산 처리2
	                    ..............
	
	               return  (계산 결과 반환)
	
	                                       } 


	예제 :  normalize <-  function(x) {
	
	          return   ((x - min(x) ) / ( max(x) - min(x) ))
	
	                                   }

		normalize( c(55,64,77,81,90) )  # 몸무게
		
		[1] 0.00 0.25 0.50 0.75 1.00
		
		normalize( c(165,172,177,181,186) )  # 키
		
		[1] 0.00 0.25 0.50 0.75 1.00
		
			    키, 몸무게, ......, 체질량 지수
			   177    78              비만
			                          복비
			                          정상 





문제180. 통계 표준화  함수 생성를 생성하시오 !

	                        x   -  μ   
	      표준화 (Z) = ---------------------
	                         표준편차
	
	 평균이 0 이고 표준편차가 1인 정규분포의 데이터로 변환 

	z_standard <-  function(x) {
	    return   ((x - mean(x) ) / ( sd(x) ))
	}

	z_standard( c(55,64,77,81,90) )  # 몸무게

	[1] -1.3234328 -0.6761015  0.2589325  0.5466353  1.1939666

	scale(c(55,64,77,81,90))

	           [,1]
	[1,] -1.3234328
	[2,] -0.6761015
	[3,]  0.2589325
	[4,]  0.5466353
	[5,]  1.1939666
	attr(,"scaled:center")
	[1] 73.4
	attr(,"scaled:scale")
	[1] 13.90324

	z_standard( c(165,172,177,181,186) )  # 키

	[1] -1.38176866 -0.51816325  0.09869776  0.59218657  1.20904758








문제181. knn 알고리즘 이해하기 위해 아래의 거리를 구하는 함수를 생성하시오 !

	  knn 알고리즘이 data 와 data 사이의 거리를 구하는 알고리즘 
	  거리를 구해서 가장 인접한 데이터가 나와 유사한 데이터이다.

	distance <- function(a, b) {
	    return  ( sqrt(sum((a-b)^2)) )
	}
	a=c(0,3,2)
	b=c(2,0,0)
	distance(a,b)
	
	[1] 4.123106











 


■ R 에서의 for  loop 문 

 문법 예제 :

          for  ( 루프변수  in  리스트 )  {
 
                         반복할 문장 
 
                                         }

 예제 :     aaa <-  function(x) {
 
                        for  ( i  in  1:x) {
 
                              print(i)

                                           }
                                }

            aaa(10) 





문제182. 아래의 파이썬 코드를 R 로 코드로 변환하시오 !
	"""
	import  csv
	file = open("d:\\emp2.csv",'r')
	emp_csv = csv.reader(file)
	a = []
	for  emp_list in emp_csv:
	    a.append(emp_list[5])
	print(a) 
	"""
	
	x <- c()
	for (i in 1:length(emp$sal)) {
	    x[i] <- emp$sal[i]
	}
	x 
	 [1]  800 1600 1250 2975 1250 2850 2450 3000 5000 1500 1100  950 3000
	[14] 1300 3200







문제183. 아래의 data frame 을 생성하시오 !

	  그림 

	a <- data.frame('데이터'=c('A','B','C','D','E','F'),
	                'x좌표'=c(1,2,4,5,6,7),
        	        'y좌표'=c(5,6,5,2,3,1),
	                '그룹'=c(rep('A',3),rep('P',3)))
	a






문제184. 아래의 그림에서 N 과 가장 거리가 가까운 과일은 무엇인가 ?
	 점심시간 문제 카페에 R 수업 게시판에 올리세요
	
	n <- c(4,4)
	a <- data.frame('데이터'=c('A','B','C','D','E','F'),
	                'x좌표'=c(1,2,4,5,6,7),
	                'y좌표'=c(5,6,5,2,3,1),
	                '그룹'=c(rep('A',3),rep('P',3)))
	distance <- function(a, b) {
	    return  ( sqrt(sum((a-b)^2)) )
	}
	temp <- c()
	for (i in 1:nrow(a)) {
	    temp[i] <- distance(n, a[i, 2:3])
	}
	temp
	a[which.min(temp), 1]













■ R에서의 if문

	if문 예제 : 
		if (조건식) {
			조건식이  true 일 때 실행되는 식
			    }
			else if (조건식) {
				조건식이 true일 때 실행되는 식
					 }
			else {
				위에 조건식들에 만족하지 않을 경우 실행되는 식
			     }





문제 185. N 과 거리가 가까운 과일을 3개를 출력하시오 !

	n <- c(4,4)
	a <- data.frame('데이터'=c('A','B','C','D','E','F'),
	                'x좌표'=c(1,2,4,5,6,7),
	                'y좌표'=c(5,6,5,2,3,1),
	                '그룹'=c(rep('A',3),rep('P',3)))
	distance <- function(a, b) {
	    return  ( sqrt(sum((a-b)^2)) )
	}
	temp <- c()
	for (i in 1:nrow(a)) {
	    temp[i] <- distance(n, a[i, 2:3])
	}
	temp
	a[which(rank(temp)<=3), 1]






문제 186. 위에 요소 A P P 중에 가장 많은 요소인 P 를 출력하시오 !

	A A P --> A
	A P P --> P
	
	n <- c(4,4)
	a <- data.frame('데이터'=c('A','B','C','D','E','F'),
	                'x좌표'=c(1,2,4,5,6,7),
	                'y좌표'=c(5,6,5,2,3,1),
	                '그룹'=c(rep('A',3),rep('P',3)))
	distance <- function(a, b) {
	    return  ( sqrt(sum((a-b)^2)) )
	}
	temp <- c()
	for (i in 1:nrow(a)) {
	    temp[i] <- distance(n, a[i, 2:3])
	}
	a1 <- a[which(rank(temp)<=3), 4]
	a2 <- table(a1)
	names(which.max(a2))












■ knn

	지도학습 -> 분류 -> knn

	* 분류문제란 새로운 데이터가 들어왔을때 이 데이터가 기존에 있던 데이터의 그룹중에 어느 그룹에 
	  속한건지를 분류하는 것을 말합니다.


	knn 은 k nearest neighbor 의 약자

	여기서 k 는 몇번째로 가까운 데이터를 살펴볼 것인가를 정한 숫자


	knn 알고리즘은 무엇인가 ?

	" k nearest neighbor 의 약자로 머신러닝의 지도학습의 분류에 해당하는 알고리즘이다. "

	  새로 들어온 데이터가 기존 데이터의 그룹에 어느 그룹에 속하는 지를 찾을 때 거리가 가까운 
	  데이터의 그룹을 자기 그룹으로 선택하는 아주 간단한 알고리즘이다.









★ knn 알고리즘의 장단점

	 - 장점 : 단순하고 효율적이다.
	     훈련 단계가 빠르다.
	
	 - 단점 : 모델을 생성하지 않아 특징과 클래스간의
	          관계를 이해하는 능력이 제약된다.

	     적절한 k 값을 사용자가 직접 알아내야 한다.

	   예 : wbcd_test_pred <- knn( train= wbcd_train, test= wbcd_test,
	                                    c1= wbcd_train_labels, k = 21 )

	   k값      테스트 데이터의 정확도
	   1         75%
	   2         79%
	   :         :

	     명목형 데이터와 결측치에 대한 추가 처리작업이 필요하다.








★ knn으로 분류하기 전에 전처리 해야하는 사항

	1. 명목형 데이터는 더미 코딩해서 숫자 0 또는 1로 변환한다.

	2. 변수간에 서로 단위가 다른 데이터이므로 min/max정규화 또는 z 표준화를 해야한다.
		- min/max함수는 데이터를 0 ~ 1 사이의 숫자로 변환 ( 정규화 )
		- z표준화는 평균이 0이고 표준편차가 1인 데이터의 분포로 구성하는 작업 ( 표준화 )

	3. 데이터를 3가지로 나눈다.
	    전체 data 가 10000개
		1. train data ( 6000개 )
		2. vaildation data ( 2000개 ) ─▶ 훈련데이터의 일부를 모델을 학습시키기 위해 쓰는 
						   데이터
		3. test data ( 2000개 ) ─▶ 실전 데이터
		4. 라벨의 class가 양성과 악성 두가지면 두개의 비율이 비슷해야 한다.
		   즉, 양성 50%, 악성 50% 로 데이터의 갯수를 맞춰주고 학습 시켜야 한다.

	※ knn은 거리를 계산하기 때문에 반드시 정규화 또는 표준화 작업을 수행해야 한다.





문제 187. 유방암 데이터의 건수와 컬럼의 갯수를 확인하시오 !

	   유방암 데이터 : wisc_bc_data.csv

	wbcd <- read.csv("wisc_bc_data.csv", header = T)
	nrow(wbcd)	# 569
	ncol(wbcd)	# 32







문제 188. 유방암 데이터의 양성(B)와 악성(M)의 건수가 각각 어떻게 되는지 확인하시오 !

	wbcd <- read.csv("wisc_bc_data.csv", header = T)
	table(wbcd$diagnosis)

	  B   M 
	357 212






문제 189. 유방암 데이터의 양성(B)과 악성(W)의 건수의 비율이 어떻게 되는지 확인하시오 !

	prop.table(table(wbcd$diagnosis))*100
	
	       B        M 
	62.74165 37.25835










■ 유방암 환자 데이터로 Knn 모델 테스트 하기



★ Knn 의 분류 실습 ( 유방암 데이터 악성과 양성 분류)

	1.데이터 게시판에서 유방암 데이터를 내려받는다

		wisc_bc_data.cv 
		
		wbcd <- read.csv("wisc_bc_data.csv", stringsAsFactors=FALSE)
	
		str(wbcd)
		
		라벨 : B --> 양성,  M --> 악성
		
		table(wbcd$diagnosis)
		  B   M 
		357 212 
		
		 총 : 569 명중 1/3 이 악성이고 2/3 가 양성이다.


	2. 라벨 컬럼을 팩터로 변환 
		wbcd$diagnosis <- factor(wbcd$diagnosis, levels = c("B","M"),
	                                 labels=c("Benign","Maliganant") )
		str(wbcd)


	3. 양성과 악성의 비율이 어떻게 되는지 확인한다.
		round( prop.table( table(wbcd$diagnosis) ), 1 ) * 100


	4. 정규화 작업 (normalize 함수로 작업)
		normalize <-  function(x) {
		    return   ((x - min(x) ) / ( max(x) - min(x) ))
		}
		wbcd_n <- as.data.frame(lapply(wbcd[,3:32], normalize) ) 

		* 정규화가 잘 되었는지 확인 ( 0 ~ 1 사이에 있는지)

		summary(wbcd_n)


	5. 훈련 데이터와 테스트(실험) 데이터를 나누는 작업 
	   ( 4/5 )        ( 1/5 )

	  " 훈련 데이터로 기계학습 시켜서 모델을 생성한후 실험 데이토로 검증하는 작업 "

		nrow(wbcd_n)
		569

		wbcd_train <- wbcd_n[1:469, ]
		wbcd_test  <- wbcd_n[470:569, ]

		wbcd_train_label <- wbcd[1:469,2]
		wbcd_test_label  <- wbcd[470:569,2]

		wbcd_test_label


	6. knn 알고리즘으로 기계학습 시켜서 모델을 생성한다.

		library(class)

		훈련데이터의 갯수 469 의 제곱근  21 

		result1 <- knn(train=wbcd_train, test=wbcd_test,
		               cl= wbcd_train_label, k = 21 )

		result1

		data.frame(wbcd[470:569,2], result1)


	7. 이 모델의 정확도가 몇 % 인지 알아내시오 ! 

		prop.table( table(ifelse(wbcd[470:569,2]==result1,"o","x" )))

		   o    x 
		0.98 0.02 

	8. 이원 교차표를 이용해서 모델을 분석하시오 !

		library(gmodels)

		CrossTable(x= wbcd[470:569,2]  , y = result1,
		           prop.chisq=FALSE )
	
		Total Observations in Table:  100 

 
		                 | result1 
		wbcd[470:569, 2] |     Benign | Maliganant |  Row Total | 
		-----------------|------------|------------|------------|
		          Benign |         61 |          0 |         61 | 
		                 |      1.000 |      0.000 |      0.610 | 
		                 |      0.968 |      0.000 |            | 
		                 |      0.610 |      0.000 |            | 
		-----------------|------------|------------|------------|
		      Maliganant |          2 |         37 |         39 | 
		                 |      0.051 |      0.949 |      0.390 | 
		                 |      0.032 |      1.000 |            | 
		                 |      0.020 |      0.370 |            | 
		-----------------|------------|------------|------------|
		    Column Total |         63 |         37 |        100 | 
		                 |      0.630 |      0.370 |            | 
		-----------------|------------|------------|------------|